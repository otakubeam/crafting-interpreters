# export {
# 
# 
#    | *Vec(a) -> a -> Unit
#    fun appendVec vector element;
# 
# 
#    | Int -> Vec(a)
#    fun makeVec initial_capacity;
# 
# 
#    | Vec(a) -> Unit
#    fun popVec vector;
# 
# 
# };


type Vec T = struct {
   data: *T,
   size: Int,
   capacity: Int,
};

of *Vec(_) -> _ -> _
fun appendVec v e = {
   if v->capacity == v->size {
     v = relocate(v, v->size);
   };

   v->data[v->size] = e;
   v->size = v->size + 1;
};


static_assert(typeof(appendVec) == *Vec(a) -> a -> Unit);


of Int -> *Vec(_)
fun makeVec capInit = {
   var v = (new _) ~> *Vec(_);
   v->capacity = capInit;
   v
};


fun memcpy src dest bytes = {
   if bytes == 0 { return unit; };
   *dest = *src;
   return memcpy(src + 1, dest + 1, bytes - 1);
};


of *Vec(_) -> _ -> _
fun relocate v sz = {
   var new_cap = 2 + sz;
   var old_data = v->data;

   v->data = (new [new_cap] Unit) ~> _;
   memcpy(old_data, v->data, sz);

   v->capacity = new_cap;

   v
};


fun main = {
   var v = makeVec(7);
   appendVec(v, 7);

   # v.appendVec(7);
   # v.vec::append(7);
};
