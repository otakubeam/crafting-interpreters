# export {
# 
# 
#    | *Vec(a) -> a -> Unit
#    fun appendVec vector element;
# 
# 
#    | Int -> Vec(a)
#    fun makeVec initial_capacity;
# 
# 
#    | Vec(a) -> Unit
#    fun popVec vector;
# 
# 
# };


type Vec T = struct {
   data: *T,
   size: Int,
   capacity: Int,
};

of Vec(_) -> _ -> _
fun appendVec v e = {
   # if v.capacity == v.size {
   #    # v = relocate(v, v.size);
   # };

   *v.data = e;
   # v.size = v.size + 1;
};

# of Int -> Vec(_)
# fun makeVec capInit = {
#    # var t = match x {
#    #    of Int: {} # do this
#    #    of (_, 123): {} # do that
#    # };
#    0 ~> Vec(_)
# };
# 
# 
# of _ -> _ -> Int -> _
# fun memcpy src dest bytes = {
#    *dest = *src;
#    return memcpy(src + 1, dest + 1, bytes - 1);
# };
# 
# 
# of Vec(_) -> _ -> _
# fun relocate v sz = {
#    var new_cap = 2 + sz;
#    var old_data = v.data;
# 
#    v.data = (new [new_cap] Unit) ~> _;
#    memcpy(old_data, v.data, sz);
# 
#    v.capacity = new_cap;
# 
#    v
# };
# 
# 



# fun main = {
#    var v = makeVec(7);
#    appendVec(v, 7);
# 
#    # v.appendVec(7);
#    # v.vec::append(7);
# };
