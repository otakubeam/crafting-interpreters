######################################################################

struct LiteralTree {
  value: Int,
};

struct Tree {
   tag: Int,
   # Number   -> 1
   # Plus     -> 2
   # Minus    -> 3
   # Multiply -> 4

   literal: LiteralTree,
   # addititon: AdditionTree,
   # multiplication: MultiplicationTree,

   left: *Tree,
   right: *Tree,
};

struct MultiplicationTree {
  left: *Tree,
  right: *Tree,

  value: Int,
};

struct AdditionTree {
  left: *Tree,
  right: *Tree,

  value: Int,
};

######################################################################

struct Token {
  ty: Int,

  # Number       -> 1
  number: Int,

  # Plus     (+) -> 2
  # Minus    (-) -> 3
  # Multiply (*) -> 4
};

######################################################################

fun parseLiteral(tokens: **Token) *Tree {
  var t = new Tree;
  var tokenTag = (*(*tokens)).ty;
  (*t).tag = tokenTag;

  assert(tokenTag == 1);
  (*t).literal.value = (*(*tokens)).number;

  # Move tokens forward
  *tokens =  *tokens + 1;

  return t;
}

fun parseAddition(tokens: **Token) *Tree {
  var t = new Tree;
  (*t).tag = 2; # Addition
  (*t).left = parseLiteral(tokens);

  # Move tokens forward
  *tokens =  *tokens + 1;

  (*t).right = parseLiteral(tokens);

  return t;
}


######################################################################

fun evaluate(tree: *Tree) Int {
  var treeTag = (*tree).tag;

  if treeTag == 1 { # Literal number
    return (*tree).literal.value;
  };

  if treeTag == 2 { # Addition
    return evaluate((*tree).left) + evaluate((*tree).right);
  };
}

######################################################################

fun main() Unit {
  var tokStream = new [6] Token;

  *(tokStream + 0) = Token:{1, 3}; # 3
  *(tokStream + 1) = Token:{2, 0}; # +
  *(tokStream + 2) = Token:{1, 9}; # 9

  var AST = parseAddition(&tokStream);
  assert(evaluate(AST) == 12);
}
