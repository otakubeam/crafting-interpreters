struct VecInt {
  data: *Int,
  size: Int,
  capacity: Int,
};

fun memcpy(dst: *Int, src: *Int, cnt: Int) Unit {
  if cnt == 0 {
    return;
  };

  *dst = *src;
  return memcpy(dst + 1, src + 1, cnt - 1);
}

fun replicate(dst: *Int, val: Int, cnt: Int) Unit {
  if cnt == 0 {
    return;
  };

  *dst = val;
  return replicate(dst + 1, val, cnt - 1);
}

fun makeVecInt(initVal: Int, size: Int) *VecInt {
  var vec = new VecInt;

  (*vec).data = new [size] Int;
  replicate((*vec).data, initVal, size);

  (*vec).size = size;
  (*vec).capacity = size;

  vec
}

fun extendCap(v: *VecInt) Unit {
  var size = (*v).size;
  var newcap = (*v).size + 10;
  var v2 = new [newcap] Int;
  memcpy(v2, (*v).data, size);
  (*v).data = v2;
  (*v).capacity = newcap;
}

fun append(v: *VecInt, val: Int) Unit {
  if (*v).capacity == (*v).size {
     extendCap(v);
  };

  *((*v).data + (*v).size) = val;
  (*v).size = (*v).size + 1;
}

fun populate(v: *VecInt, cur: Int, left: Int) Unit {
  if left == 0 {
    return;
  };
  append(v, cur);
  return populate(v, cur+1, left-1);
}

fun at(v: *VecInt, i: Int) Int {
  assert((*v).size > i);
  *((*v).data + i)
}

fun main() Unit {
  var t1 = makeVecInt(1, 1);
  populate(t1, 2, 4);

  assert(at(t1, 0) == 1);
  assert(at(t1, 1) == 2);
  assert(at(t1, 2) == 3);
  assert(at(t1, 3) == 4);
  assert(at(t1, 4) == 5);
  assert(at(t1, 4) == 5);
}
